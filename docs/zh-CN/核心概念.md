# Prometheus 核心概念

本文档介绍 Prometheus 系统中的核心概念和关键术语。

## 1. 统一知识图谱 (Unified Knowledge Graph)

### 什么是统一知识图谱？

统一知识图谱是 Prometheus 的核心创新，它将代码库的多个维度整合到一个图结构中：

- **文件层次结构**：目录和文件的组织关系
- **抽象语法树 (AST)**：代码的语法结构
- **语义关系**：代码元素之间的逻辑关系
- **文本块**：用于向量搜索的代码片段

### 图的组成元素

**节点类型**：
- `FileNode`：表示文件或目录
  - 属性：路径、类型（文件/目录）、大小
- `ASTNode`：表示 AST 节点
  - 属性：节点类型、文本、起始/结束位置
- `TextNode`：表示文本块
  - 属性：内容、块索引、向量嵌入

**边类型**：
- `HAS_FILE`：目录包含文件的关系
- `HAS_AST`：文件包含 AST 的关系
- `HAS_TEXT`：文件包含文本块的关系
- `PARENT_OF`：AST 节点的父子关系
- `NEXT_CHUNK`：文本块的顺序关系

### 为什么使用图？

传统的代码分析工具通常只关注单一维度（如文件结构或 AST），而 Prometheus 通过图结构将这些维度统一起来，使得：

1. **语义搜索更精准**：可以同时考虑代码结构和语义
2. **上下文更完整**：可以快速找到相关的代码片段
3. **查询更灵活**：支持复杂的图遍历查询
4. **多语言统一**：所有语言使用相同的表示方法

### 示例图查询

```cypher
// 查找所有包含特定函数的文件
MATCH (f:FileNode)-[:HAS_AST]->(a:ASTNode)
WHERE a.type = 'function_definition' AND a.text CONTAINS 'process_issue'
RETURN f.path

// 查找函数的所有调用者
MATCH (caller:ASTNode)-[:CALLS]->(callee:ASTNode)
WHERE callee.name = 'build_knowledge_graph'
RETURN caller
```

## 2. 多智能体系统 (Multi-Agent System)

### 什么是多智能体系统？

Prometheus 使用多个专门的 AI 智能体协同工作来解决问题，而不是依赖单一的大模型。每个智能体负责特定的任务。

### 核心智能体

#### 2.1 问题分类智能体 (Issue Classification Agent)

**职责**：
- 分析 issue 的内容
- 确定 issue 类型（bug、feature、question、documentation）
- 为后续流程提供路由信息

**工作流程**：
1. 检索相关代码上下文
2. 使用 LLM 分析 issue 内容
3. 返回分类结果

**位置**：`prometheus/lang_graph/subgraphs/issue_classification_subgraph.py`

#### 2.2 错误重现智能体 (Bug Reproduction Agent)

**职责**：
- 尝试重现报告的错误
- 编写重现测试
- 验证错误是否真实存在

**工作流程**：
1. 检索错误相关的代码上下文
2. 使用 LLM 生成重现测试代码
3. 在 Docker 容器中执行测试
4. 评估是否成功重现
5. 如果失败，根据反馈重试

**关键特性**：
- 迭代改进（最多 N 次重试）
- Docker 隔离执行
- 反馈驱动的优化

**位置**：`prometheus/lang_graph/subgraphs/bug_reproduction_subgraph.py`

#### 2.3 上下文检索智能体 (Context Retrieval Agent)

**职责**：
- 从知识图谱中检索相关代码
- 提取有用的代码片段和文档
- 为其他智能体提供上下文

**工作流程**：
1. 将自然语言查询转换为图查询
2. 使用带工具的 LLM 遍历知识图谱
3. 选择和提取有用的代码片段
4. 可选：如果上下文不足，优化查询并重试

**关键特性**：
- 迭代查询优化（2-4 轮）
- 工具增强的 LLM（可访问 Neo4j）
- 遍历文件层次、AST 结构和文本块

**位置**：`prometheus/lang_graph/subgraphs/context_retrieval_subgraph.py`

#### 2.4 问题解决智能体 (Issue Resolution Agent)

**职责**：
- 为已验证的错误生成修复补丁
- 验证补丁的正确性
- 选择最佳补丁

**工作流程**：
1. 检索修复相关的代码上下文
2. 使用 LLM 分析错误根因
3. 生成多个候选补丁
4. 应用补丁并生成 git diff
5. 多级验证：
   - 重现测试（必须通过）
   - 回归测试（可选）
   - 现有测试套件（可选）
6. 使用 LLM 选择最佳补丁
7. 如果测试失败，根据错误反馈重试

**关键特性**：
- 多候选补丁生成（默认 6 个）
- 多级验证机制
- 反馈驱动的迭代
- 智能补丁选择

**位置**：`prometheus/lang_graph/subgraphs/issue_verified_bug_subgraph.py`

#### 2.5 功能实现智能体 (Feature Implementation Agent)

**职责**：
- 分析功能请求
- 规划实现方案
- 生成功能代码

**工作流程**：
1. 检索相关代码上下文
2. 分析功能需求
3. 规划实现步骤
4. 生成代码
5. 可选回归测试

**位置**：`prometheus/lang_graph/subgraphs/issue_feature_subgraph.py`

#### 2.6 问答智能体 (Question Answering Agent)

**职责**：
- 回答关于代码库的问题
- 提供详细的技术解释
- 引用相关代码片段

**工作流程**：
1. 检索相关代码和文档
2. 使用工具增强的 LLM 分析
3. 生成答案

**位置**：`prometheus/lang_graph/subgraphs/issue_question_subgraph.py`

#### 2.7 文档更新智能体 (Documentation Agent)

**职责**：
- 分析文档更新请求
- 生成或更新文档
- 确保文档与代码一致

**位置**：`prometheus/lang_graph/subgraphs/issue_documentation_subgraph.py`

### 智能体协作模式

智能体之间通过 **LangGraph 状态机** 进行协作：

1. **共享状态**：所有智能体共享一个状态字典
2. **状态继承**：子图继承父状态
3. **状态更新**：每个节点更新状态的特定部分
4. **状态传递**：通过返回值传递结果

示例状态流：
```
IssueState = {
    "issue_type": "bug",
    "issue_content": "...",
    "contexts": [...],
    "reproduced_bug": True,
    "edit_patch": "...",
    "test_results": {...}
}
```

## 3. LangGraph 状态机

### 什么是 LangGraph？

LangGraph 是一个用于构建多智能体工作流的框架，基于状态机模型。

### 核心概念

#### 3.1 节点 (Node)

节点是工作流中的原子操作，可以是：
- LLM 调用
- 工具调用
- 数据处理
- 条件判断

示例节点：
```python
def bug_analyzer_node(state: IssueState) -> dict:
    """分析 bug 的根因"""
    # 调用 LLM 分析
    analysis = llm.invoke(...)

    # 更新状态
    return {
        "analysis": analysis,
        "messages": state["messages"] + [analysis]
    }
```

#### 3.2 边 (Edge)

边定义了节点之间的连接关系，可以是：
- **静态边**：固定的流程
- **条件边**：根据状态动态路由

示例条件边：
```python
def route_by_issue_type(state: IssueState) -> str:
    """根据 issue 类型路由"""
    if state["issue_type"] == "bug":
        return "bug_pipeline"
    elif state["issue_type"] == "feature":
        return "feature_pipeline"
    else:
        return "question_pipeline"
```

#### 3.3 子图 (Subgraph)

子图是嵌套的工作流，可以被其他图调用。优点：
- 模块化
- 可复用
- 易于测试

#### 3.4 状态 (State)

状态是一个字典，包含工作流的所有数据。状态通过节点和边传递。

### 主工作流

```
用户 Issue
    ↓
问题分类智能体
    ↓
[根据类型路由]
    ↓
├─ Bug 流程
│  ├─ 上下文检索
│  ├─ 错误重现
│  ├─ 问题解决
│  └─ 响应生成
│
├─ Feature 流程
│  ├─ 上下文检索
│  ├─ 功能分析
│  ├─ 代码生成
│  └─ 响应生成
│
└─ Question 流程
   ├─ 上下文检索
   ├─ 问题分析
   └─ 答案生成
```

## 4. Tree-sitter 代码解析

### 什么是 Tree-sitter？

Tree-sitter 是一个增量解析库，可以构建代码的抽象语法树 (AST)。

### 为什么使用 Tree-sitter？

1. **语言无关**：支持 20+ 种编程语言
2. **增量解析**：快速更新 AST
3. **容错性强**：可以解析不完整的代码
4. **无需执行**：静态分析，不需要运行代码

### 支持的语言

Python, JavaScript, TypeScript, Java, C++, Go, Rust, Ruby, PHP, C#, Kotlin, Swift, Scala, Shell, YAML, JSON, TOML, Dockerfile, Markdown, SQL, CSS, HTML, XML, Properties

### AST 示例

对于代码：
```python
def hello(name):
    print(f"Hello, {name}!")
```

生成的 AST（简化）：
```
function_definition
├── name: "hello"
├── parameters
│   └── identifier: "name"
└── block
    └── expression_statement
        └── call
            ├── function: "print"
            └── argument: f-string
```

### 在 Prometheus 中的使用

```python
from prometheus.parser.tree_sitter_parser import TreeSitterParser

parser = TreeSitterParser()
ast = parser.parse_file("example.py", file_type="python")

# AST 节点包含：
# - type: 节点类型（如 "function_definition"）
# - text: 节点的源代码文本
# - start_point: 起始位置（行号，列号）
# - end_point: 结束位置
# - children: 子节点列表
```

## 5. Docker 容器隔离

### 为什么使用 Docker？

1. **安全性**：隔离不受信任的代码执行
2. **一致性**：提供一致的运行环境
3. **可配置性**：支持自定义运行时
4. **清理简单**：容器销毁后不留痕迹

### 容器类型

#### 5.1 通用容器 (General Container)

基于 Ubuntu，包含常用开发工具：
- 编译器：gcc, g++, cmake
- 解释器：Python, Node.js, Java
- 版本控制：git
- 构建工具：make, npm, pip

#### 5.2 用户自定义容器

支持用户提供自己的 Dockerfile 或镜像名称，用于特殊的运行时需求。

### 使用示例

```python
from prometheus.docker.general_container import GeneralContainer

# 创建容器
container = GeneralContainer()

# 执行命令
result = container.execute_command(
    "pytest tests/",
    working_dir="/app",
    timeout=300
)

# 获取输出
print(result.stdout)
print(result.stderr)
print(result.exit_code)
```

## 6. 多级验证机制

Prometheus 使用多级验证确保生成的补丁质量：

### 6.1 重现测试 (Reproduction Test)

- **目的**：验证补丁确实修复了报告的 bug
- **方法**：运行由 Bug Reproduction Agent 生成的测试
- **要求**：补丁应用后，测试必须通过

### 6.2 回归测试 (Regression Test)

- **目的**：确保补丁不会引入新的错误
- **方法**：运行一组选定的测试用例
- **要求**：所有回归测试必须通过

### 6.3 现有测试 (Existing Test)

- **目的**：确保补丁不破坏现有功能
- **方法**：运行项目的完整测试套件
- **要求**：所有现有测试必须通过

### 验证流程

```
生成候选补丁
    ↓
应用补丁
    ↓
运行重现测试 ✓
    ↓
运行回归测试 ✓
    ↓
运行现有测试 ✓
    ↓
验证通过 → 选择最佳补丁
```

如果任何验证失败，系统会：
1. 记录失败原因
2. 将错误信息作为反馈
3. 重新生成补丁
4. 重复验证流程

## 7. LLM 集成

### 支持的模型

Prometheus 支持多个 LLM 提供商：

1. **OpenAI**：GPT-4, GPT-3.5
2. **Anthropic**：Claude 3.5, Claude 3
3. **Google**：Gemini Pro, Gemini Ultra

### 分层模型策略

Prometheus 使用两层模型：

- **高级模型** (`ADVANCED_MODEL`)：用于复杂任务
  - 代码生成
  - 错误分析
  - 补丁生成

- **基础模型** (`BASE_MODEL`)：用于简单任务
  - 问题分类
  - 文本提取
  - 简单判断

### 工具调用 (Tool Calling)

LLM 可以调用工具来完成任务：

```python
tools = [
    GraphTraversalTool(),  # 图遍历
    FileOperationTool(),   # 文件操作
    WebSearchTool()        # Web 搜索
]

llm_with_tools = llm.bind_tools(tools)
response = llm_with_tools.invoke("找到所有 API 路由定义")
```

## 8. 上下文管理

### 什么是上下文？

上下文是与当前任务相关的代码片段、文档和元数据。

### 上下文模型

```python
class Context(BaseModel):
    file_path: str           # 文件路径
    start_line: int          # 起始行号
    end_line: int            # 结束行号
    content: str             # 代码内容
    relevance_score: float   # 相关性分数
```

### 上下文检索策略

1. **基于查询的检索**：
   - 将自然语言转换为图查询
   - 遍历知识图谱
   - 提取相关节点

2. **基于相似度的检索**：
   - 使用向量嵌入
   - 计算相似度
   - 返回最相关的片段

3. **基于启发式的检索**：
   - 文件名匹配
   - 函数名匹配
   - 导入关系

### 上下文优化

- **去重**：移除重复的代码片段
- **排序**：按相关性排序
- **截断**：限制上下文长度以适应 LLM 的 token 限制
- **合并**：合并相邻的代码片段

## 9. 状态检查点 (Checkpointing)

### 什么是检查点？

检查点是工作流状态的持久化快照，允许：
- 长时间运行的任务
- 故障恢复
- 人工介入
- 状态回溯

### 检查点存储

Prometheus 使用 PostgreSQL 存储检查点：

```python
from langgraph_checkpoint_postgres import PostgresCheckpointer

checkpointer = PostgresCheckpointer(db_url)
```

### 检查点使用

```python
# 保存检查点
graph.invoke(
    state,
    config={"configurable": {"thread_id": "123"}}
)

# 恢复检查点
state = graph.get_state({"configurable": {"thread_id": "123"}})
```

## 10. 术语表

| 术语 | 英文 | 解释 |
|------|------|------|
| 知识图谱 | Knowledge Graph | 代码的图结构表示 |
| 智能体 | Agent | 执行特定任务的 AI 组件 |
| 状态机 | State Machine | 定义工作流的图结构 |
| 节点 | Node | 工作流中的单个步骤 |
| 边 | Edge | 节点之间的连接 |
| 子图 | Subgraph | 嵌套的工作流 |
| AST | Abstract Syntax Tree | 抽象语法树 |
| 上下文 | Context | 相关的代码片段 |
| 补丁 | Patch | 代码修改的 diff |
| 检查点 | Checkpoint | 状态的持久化快照 |
| 工具 | Tool | LLM 可以调用的函数 |
| 向量嵌入 | Vector Embedding | 文本的数值表示 |

## 总结

Prometheus 的核心概念围绕着：

1. **知识表示**：统一知识图谱
2. **智能协作**：多智能体系统
3. **工作流编排**：LangGraph 状态机
4. **代码理解**：Tree-sitter 解析
5. **安全执行**：Docker 容器
6. **质量保证**：多级验证
7. **灵活集成**：多 LLM 支持

理解这些概念是掌握 Prometheus 的关键。
