# Prometheus 架构设计

本文档详细介绍 Prometheus 的系统架构和设计理念。

## 整体架构

Prometheus 采用分层架构设计，从下到上分为以下几层：

```
┌─────────────────────────────────────────────────────────┐
│                    API Layer (FastAPI)                  │
│  ┌──────────┬──────────┬──────────┬──────────────────┐ │
│  │  Auth    │  Issue   │  Repo    │  GitHub Token    │ │
│  │  Routes  │  Routes  │  Routes  │  Routes          │ │
│  └──────────┴──────────┴──────────┴──────────────────┘ │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                   Service Layer                         │
│  ┌──────────┬──────────┬──────────┬──────────────────┐ │
│  │  Issue   │  KG      │  Repo    │  LLM             │ │
│  │  Service │  Service │  Service │  Service         │ │
│  └──────────┴──────────┴──────────┴──────────────────┘ │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│              Agent Orchestration (LangGraph)            │
│  ┌──────────┬──────────┬──────────┬──────────────────┐ │
│  │  Issue   │  Bug     │  Feature │  Question        │ │
│  │  Classify│  Pipeline│  Pipeline│  Pipeline        │ │
│  └──────────┴──────────┴──────────┴──────────────────┘ │
│  ┌──────────┬──────────┬──────────┬──────────────────┐ │
│  │  Context │  Bug     │  Patch   │  Validation      │ │
│  │ Retrieval│ Reproduce│  Generate│  Pipeline        │ │
│  └──────────┴──────────┴──────────┴──────────────────┘ │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                Knowledge & Tools Layer                   │
│  ┌──────────┬──────────┬──────────┬──────────────────┐ │
│  │Knowledge │  Graph   │  File    │  Container       │ │
│  │  Graph   │Traversal │Operations│  Commands        │ │
│  └──────────┴──────────┴──────────┴──────────────────┘ │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│               Infrastructure Layer                       │
│  ┌──────────┬──────────┬──────────┬──────────────────┐ │
│  │  Neo4j   │PostgreSQL│  Docker  │  Git             │ │
│  │  Graph   │  State   │Container │  Repository      │ │
│  │  DB      │Checkpoint│          │                  │ │
│  └──────────┴──────────┴──────────┴──────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

## 核心组件详解

### 1. API 层（FastAPI）

#### 1.1 职责

- 接收 HTTP 请求
- 验证输入参数
- 处理认证和授权
- 调用服务层
- 返回响应结果

#### 1.2 主要端点

**认证端点** (`/v1.2/auth/`)：
```
POST   /register        - 用户注册
POST   /login           - 用户登录
POST   /refresh         - 刷新 token
```

**问题分析端点** (`/v1.2/issues/`)：
```
POST   /answer/         - 分析和解决问题（主要端点）
GET    /:id             - 获取问题状态
```

**仓库管理端点** (`/v1.2/repositories/`)：
```
POST   /upload          - 上传仓库
GET    /:id             - 获取仓库信息
POST   /branch          - 创建分支
```

**GitHub 端点** (`/v1.2/github/`)：
```
POST   /token           - 保存 GitHub token
GET    /token           - 获取 GitHub token
DELETE /token           - 删除 GitHub token
```

#### 1.3 中间件

**JWT 认证中间件**：
- 验证 JWT token
- 提取用户信息
- 注入到请求上下文

**异常处理中间件**：
- 捕获所有异常
- 转换为标准错误响应
- 记录错误日志

#### 1.4 依赖注入

```python
from fastapi import Depends
from prometheus.app.dependencies import get_issue_service

@router.post("/answer/")
async def answer_issue(
    request: IssueRequest,
    service: IssueService = Depends(get_issue_service)
):
    return await service.answer_issue(request)
```

### 2. 服务层

#### 2.1 IssueService - 问题处理服务

**职责**：
- 协调整个问题解决流程
- 调用 LangGraph 工作流
- 管理状态和结果

**核心方法**：
```python
async def answer_issue(self, request: IssueRequest) -> IssueResponse:
    """
    处理问题的主入口

    流程：
    1. 验证仓库
    2. 构建知识图谱（如果需要）
    3. 创建 LangGraph 状态
    4. 调用主工作流
    5. 处理结果
    6. 返回响应
    """
```

#### 2.2 KnowledgeGraphService - 知识图谱服务

**职责**：
- 构建代码库的知识图谱
- 管理图的持久化
- 提供图查询接口

**核心方法**：
```python
async def build_graph(self, repository_path: str) -> KnowledgeGraph:
    """
    构建知识图谱

    流程：
    1. 扫描文件系统
    2. 使用 tree-sitter 解析代码
    3. 构建图节点和边
    4. 持久化到 Neo4j
    5. 生成文本块和嵌入
    """
```

#### 2.3 RepositoryService - 仓库服务

**职责**：
- 克隆和管理 Git 仓库
- 创建分支
- 应用补丁

**核心方法**：
```python
async def upload_repository(self, url: str, branch: str) -> Repository:
    """
    上传仓库

    流程：
    1. 验证仓库 URL
    2. 克隆仓库
    3. 检出指定分支
    4. 保存仓库元数据
    5. 触发知识图谱构建
    """
```

#### 2.4 LLMService - LLM 服务

**职责**：
- 管理多个 LLM 提供商
- 提供统一的 LLM 调用接口
- 处理 API 密钥和配置

**支持的提供商**：
- OpenAI (GPT-4, GPT-3.5)
- Anthropic (Claude)
- Google (Gemini)

### 3. 智能体编排层（LangGraph）

#### 3.1 主工作流（IssueGraph）

**流程图**：

```
                    START
                      │
                      ↓
            ┌─────────────────┐
            │Issue            │
            │Classification   │
            └────────┬────────┘
                     │
           ┌─────────┴────────┐
           │  Route by Type   │
           └─────────┬────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
        ↓            ↓            ↓
   ┌────────┐  ┌────────┐  ┌────────┐
   │  Bug   │  │Feature │  │Question│
   │Pipeline│  │Pipeline│  │Pipeline│
   └───┬────┘  └───┬────┘  └───┬────┘
       │           │            │
       └───────────┴────────────┘
                   │
                   ↓
            ┌─────────────────┐
            │Response         │
            │Generation       │
            └────────┬────────┘
                     │
                     ↓
                    END
```

#### 3.2 Bug 处理流程

**详细流程**：

```
Bug Issue
    │
    ↓
┌──────────────────────┐
│Select Regression     │  ← 选择回归测试
│Tests                 │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Bug Reproduction      │  ← 尝试重现错误
│  1. Generate test    │
│  2. Execute test     │
│  3. Evaluate result  │
└──────┬───────────────┘
       │
       ├─ Reproduced ────────────┐
       │                         │
       └─ Not Reproduced         │
              │                  │
              ↓                  ↓
    ┌──────────────────┐  ┌──────────────────┐
    │Direct Resolution │  │Verified Bug      │
    │  1. Analyze      │  │  1. Analyze      │
    │  2. Generate fix │  │  2. Generate fix │
    │  3. No validation│  │  3. Multi-level  │
    │                  │  │     validation   │
    └─────┬────────────┘  └─────┬────────────┘
          │                     │
          └──────────┬──────────┘
                     │
                     ↓
            ┌──────────────────┐
            │Response          │
            │Generation        │
            └──────────────────┘
```

**验证流程**（仅对已重现的 bug）：

```
Generate Candidate Patches (N patches)
    │
    ├─ Patch 1 ───┐
    ├─ Patch 2 ───┤
    ├─ ...     ───┼─→ For each patch:
    └─ Patch N ───┘       │
                          ↓
                   ┌──────────────────┐
                   │Apply Patch       │
                   └──────┬───────────┘
                          │
                          ↓
                   ┌──────────────────┐
                   │Reproduction Test │ ← Must pass
                   └──────┬───────────┘
                          │
                          ↓
                   ┌──────────────────┐
                   │Regression Test   │ ← Optional
                   └──────┬───────────┘
                          │
                          ↓
                   ┌──────────────────┐
                   │Existing Test     │ ← Optional
                   └──────┬───────────┘
                          │
                          ↓
                   ┌──────────────────┐
                   │Record Results    │
                   └──────────────────┘
                          │
                          ↓
            Select Best Patch (using LLM)
```

#### 3.3 Feature 实现流程

```
Feature Request
    │
    ↓
┌──────────────────────┐
│Context Retrieval     │  ← 检索相关代码
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Feature Analysis      │  ← 分析需求
│  1. Understand req   │
│  2. Plan impl        │
│  3. Identify files   │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Code Generation       │  ← 生成代码
│  1. Generate code    │
│  2. Create patch     │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Optional Regression   │  ← 可选测试
│Test                  │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Response Generation   │
└──────────────────────┘
```

#### 3.4 Question 回答流程

```
Question
    │
    ↓
┌──────────────────────┐
│Context Retrieval     │  ← 检索相关信息
│  1. Parse query      │
│  2. Search graph     │
│  3. Extract context  │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Question Analysis     │  ← LLM with Tools
│  1. Use graph tool   │
│  2. Use file tool    │
│  3. Use web search   │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Answer Generation     │  ← 生成答案
└──────────────────────┘
```

#### 3.5 上下文检索子图

这是一个被多个流程共享的关键子图：

```
Query
    │
    ↓
┌──────────────────────┐
│Convert to Graph      │  ← 自然语言 → 图查询
│Query                 │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│LLM with Graph Tools  │  ← 使用工具遍历图
│  - find_files        │
│  - find_ast_nodes    │
│  - read_file         │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│Extract Context       │  ← 提取有用片段
└──────┬───────────────┘
       │
       ├─ Sufficient ────→ Return
       │
       └─ Insufficient
              │
              ↓
       ┌──────────────┐
       │Refine Query  │
       └──────┬───────┘
              │
              └─→ Retry (max 2-4 times)
```

### 4. 知识与工具层

#### 4.1 知识图谱

**图结构**：

```
Repository Root
    │
    ├─ Directory
    │   ├─ File 1
    │   │   ├─ AST Root
    │   │   │   ├─ Function Def
    │   │   │   │   ├─ Parameter
    │   │   │   │   └─ Block
    │   │   │   └─ Class Def
    │   │   └─ Text Chunks
    │   │       ├─ Chunk 1
    │   │       ├─ Chunk 2
    │   │       └─ Chunk 3
    │   └─ File 2
    └─ Directory 2
```

**节点属性**：

```python
FileNode:
    - id: str
    - path: str
    - type: "file" | "directory"
    - size: int
    - last_modified: datetime

ASTNode:
    - id: str
    - type: str (e.g., "function_definition")
    - text: str (source code)
    - start_point: (line, column)
    - end_point: (line, column)
    - language: str

TextNode:
    - id: str
    - content: str
    - chunk_index: int
    - embedding: List[float]
```

**边关系**：

```
(Directory)-[:HAS_FILE]->(File)
(File)-[:HAS_AST]->(AST Root)
(AST Parent)-[:PARENT_OF]->(AST Child)
(File)-[:HAS_TEXT]->(Text Chunk)
(Text Chunk)-[:NEXT_CHUNK]->(Next Chunk)
```

#### 4.2 工具系统

**图遍历工具**：

```python
class GraphTraversalTool:
    def find_files_by_name(self, basename: str) -> List[str]
    def find_files_by_path(self, path_pattern: str) -> List[str]
    def find_ast_nodes_by_type(self, node_type: str) -> List[ASTNode]
    def find_ast_nodes_by_text(self, text: str) -> List[ASTNode]
    def find_text_chunks(self, query: str) -> List[TextNode]
    def read_file(self, file_path: str) -> str
    def preview_file(self, file_path: str, lines: int = 10) -> str
```

**文件操作工具**：

```python
class FileOperationTool:
    def read_file(self, path: str) -> str
    def write_file(self, path: str, content: str) -> bool
    def edit_file(self, path: str, start_line: int, end_line: int, new_content: str) -> bool
    def create_file(self, path: str, content: str) -> bool
    def delete_file(self, path: str) -> bool
    def create_directory(self, path: str) -> bool
```

**容器命令工具**：

```python
class ContainerCommandTool:
    def execute(self, command: str, timeout: int = 300) -> CommandResult
    def build(self, build_commands: List[str]) -> BuildResult
    def test(self, test_commands: List[str]) -> TestResult
```

**Web 搜索工具**：

```python
class WebSearchTool:
    def search(self, query: str, max_results: int = 5) -> List[SearchResult]
```

### 5. 基础设施层

#### 5.1 Neo4j 图数据库

**用途**：
- 持久化知识图谱
- 提供图查询能力
- 支持复杂的图遍历

**配置**：
```yaml
version: "3.8"
services:
  neo4j:
    image: neo4j
    ports:
      - "7474:7474"  # HTTP
      - "7687:7687"  # Bolt
    environment:
      NEO4J_AUTH: neo4j/password
      NEO4J_PLUGINS: '["apoc"]'
      NEO4J_dbms_memory_heap_initial__size: 4G
      NEO4J_dbms_memory_heap_max__size: 8G
```

**APOC 插件**：
- 图算法
- 批量操作
- 数据导入/导出

#### 5.2 PostgreSQL 数据库

**用途**：
- 存储 LangGraph 状态检查点
- 持久化应用数据（用户、仓库等）
- 支持事务

**表结构**：

```sql
-- 用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 仓库表
CREATE TABLE repositories (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    url VARCHAR(512) NOT NULL,
    branch VARCHAR(255) NOT NULL,
    local_path VARCHAR(512),
    status VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW()
);

-- LangGraph 检查点表
CREATE TABLE checkpoints (
    thread_id VARCHAR(255) PRIMARY KEY,
    checkpoint_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

#### 5.3 Docker 容器

**用途**：
- 隔离代码执行环境
- 运行测试和构建
- 确保一致性和安全性

**容器生命周期**：

```
Create Container
    │
    ↓
Copy Code to Container
    │
    ↓
Execute Commands
    │
    ├─ Build Commands
    ├─ Test Commands
    └─ Reproduction Commands
    │
    ↓
Collect Results
    │
    ↓
Cleanup Container
```

#### 5.4 Git 仓库管理

**操作流程**：

```
Clone Repository
    │
    ↓
Checkout Branch
    │
    ↓
Apply Patch
    │
    ↓
Run Tests
    │
    ├─ Pass → Commit & Push
    │
    └─ Fail → Reset & Retry
```

## 数据流

### 完整的数据流示例（Bug 修复）

```
1. User Request
   ↓
   {
     repository_url: "https://github.com/user/repo",
     issue_type: "bug",
     issue_content: "Application crashes...",
     run_build: true,
     run_test: true
   }

2. API Layer
   ↓
   - Validate request
   - Authenticate user
   - Call IssueService

3. Service Layer
   ↓
   - Clone repository
   - Build knowledge graph
   - Create LangGraph state
   - Invoke main workflow

4. Agent Layer
   ↓
   State = {
     issue_type: "bug",
     issue_content: "...",
     repository_path: "/path/to/repo",
     contexts: [],
     reproduced_bug: null,
     edit_patch: null,
     test_results: {}
   }

5. Issue Classification
   ↓
   State.issue_type = "bug"
   → Route to Bug Pipeline

6. Bug Reproduction
   ↓
   - Context Retrieval:
     State.contexts = [
       {file: "main.py", lines: [10, 30], content: "..."},
       {file: "utils.py", lines: [5, 15], content: "..."}
     ]

   - Generate Reproduction Test:
     State.reproduced_bug_file = "test_reproduction.py"
     State.reproduced_bug_commands = ["pytest test_reproduction.py"]

   - Execute Test:
     State.reproduced_bug = true

7. Patch Generation
   ↓
   - Generate 6 candidate patches
   - For each patch:
     * Apply patch
     * Run reproduction test
     * Run regression tests
     * Run existing tests
     * Record results

   State.edit_patch = "--- a/main.py\n+++ b/main.py\n..."
   State.test_results = {
     reproduction_test: "passed",
     regression_tests: "passed",
     existing_tests: "passed"
   }

8. Response Generation
   ↓
   State.issue_response = "分析报告：..."

9. Return to Service Layer
   ↓
   {
     issue_type: "bug",
     issue_response: "...",
     edit_patch: "...",
     passed_reproducing_test: true,
     passed_regression_test: true,
     passed_existing_test: true
   }

10. Return to User
    ↓
    HTTP 200 OK
    {
      success: true,
      data: {...}
    }
```

## 扩展点

### 1. 添加新的 LLM 提供商

在 `prometheus/chat_models/` 中添加新的适配器。

### 2. 添加新的编程语言支持

在 `prometheus/parser/` 中添加 tree-sitter 语言支持。

### 3. 添加新的工具

在 `prometheus/tools/` 中实现新的工具类。

### 4. 添加新的验证步骤

在 Bug 验证子图中添加新的验证节点。

### 5. 添加新的问题类型

创建新的问题处理流程子图。

## 性能优化

### 1. 知识图谱构建优化

- 并行解析文件
- 批量插入节点和边
- 增量更新（只解析修改的文件）

### 2. 上下文检索优化

- 使用向量索引加速搜索
- 缓存常用查询结果
- 限制图遍历深度

### 3. LLM 调用优化

- 使用流式响应
- 实现请求批处理
- 缓存重复查询

### 4. 容器执行优化

- 重用容器实例
- 并行运行测试
- 实现超时机制

## 安全考虑

### 1. 代码执行隔离

- 所有代码在 Docker 容器中执行
- 限制容器资源（CPU、内存）
- 网络隔离

### 2. 认证和授权

- JWT token 认证
- HTTPS 加密通信
- API 速率限制

### 3. 输入验证

- 严格的参数验证
- 防止 SQL 注入
- 防止路径遍历攻击

### 4. 敏感信息保护

- 环境变量存储密钥
- 不在日志中记录密钥
- 加密存储用户密码

## 监控和日志

### 1. 日志级别

- DEBUG：详细调试信息
- INFO：一般信息
- WARNING：警告信息
- ERROR：错误信息
- CRITICAL：严重错误

### 2. 日志内容

- 请求/响应
- LLM 调用
- 图操作
- 容器执行
- 错误堆栈

### 3. 监控指标

- API 响应时间
- LLM 调用次数和耗时
- 知识图谱构建时间
- 容器执行成功率
- 补丁验证通过率

## 总结

Prometheus 的架构设计体现了以下原则：

1. **模块化**：清晰的分层和组件划分
2. **可扩展**：易于添加新功能和集成
3. **可测试**：每个组件都可以独立测试
4. **高性能**：并行处理和缓存优化
5. **安全性**：隔离执行和严格验证
6. **可维护**：清晰的代码结构和文档

通过这种架构，Prometheus 能够高效、可靠地处理各种代码问题，并提供可验证的解决方案。
